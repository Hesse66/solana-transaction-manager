Design a blueprint for a coder LLM to solve problems effectively, reason internally following the NFOP_RJST guidelines, approach the problem-solving following the MONOCODE guidelines of familiarity and output your final blueprint by following the FOA guidelines and its outpute template.

NFOP_RJST
---
NLIR First Principles
```yaml
first_principles:
  nlir_reasoning: 
    - Utilize the Natural Language Inherent Reasoning (NLIR) framework to break down the problem into a structured series of sub-questions and answers.
    -  Employ a flow of questions, starting with a high-level question and progressively breaking it down into more manageable sub-questions.
    - **Structured Response Framework:**
      - Employ the Structured Response Framework to formulate answers to sub-questions:
        - **Structured Natural Language Templates:** Use predefined templates that mimic programming structures (e.g., "If [condition], then [action], otherwise [alternative action]").
        - **Decision Trees in Text:** Create textual decision trees for classification or complex decision-making.
        - **State-based Reasoning:**  After answering each sub-question, describe the current state of the problem in clear natural language. Update this state based on the answer to the sub-question.
    - **Advantages:**
      - NLIR promotes accuracy by providing a structured reasoning framework that minimizes ambiguity.
      - The use of natural language throughout the process enhances interpretability, making the reasoning steps transparent and understandable. 
  flow_of_thought:
    - Think step-by-step, systematically addressing each sub-question and updating the problem state accordingly. 
    - Explicitly describe the reasoning behind each answer and how it affects the overall solution. 
  general_guidelines:
    - Clearly define the initial state of the problem, including any relevant variables or data.
    - Maintain a clear and consistent representation of the problem state throughout the reasoning process.
    - Use precise language and avoid ambiguity when describing conditions, actions, and states.
```
---
NLER First Principles
```yaml
first_principles:
  nler_finding:
    - Utilize the Natural Language Effective Reasoning (NLER) framework to keep your reasoning focused and find the optimal solution effectively.
    - Employ flow of heuristics by integrating the Heuristic Selection and Optimization Framework (HSOF) to select and optimize the most appropriate heuristics for the problem.
    - Effective Reasoning Framework:
        - Heuristic Selection and Optimization Framework (HSOF):
            Description: >
              Apply the HSOF to thoroughly analyze the problem, select and optimize suitable heuristics, and facilitate human-like reasoning for effective problem-solving and decision-making.
            Components:
              - **Analyze the Problem**:
                  - **Nature of Problem**: Determine if the problem is domain-specific, cross-domain, structured, or unstructured.
                  - **Complexity**: Evaluate both algorithmic and cognitive complexities.
                  - **Data Availability**: Assess the quality, quantity, and type (structured, semi-structured, unstructured) of available data.
                  - **Flexibility and Adaptability**: Identify the need for dynamic solutions and scalability requirements.
                  - **Resource Constraints**: Consider computational resources, time constraints, and budget limitations.
                  - **Desired Outcomes**: Clarify goals regarding accuracy, efficiency, interpretability, and ethical considerations.
                  - **Human-Like Reasoning**: Incorporate intuition, contextual understanding, and emotional intelligence into the reasoning process.
              - **Select and Optimize Heuristics**:
                  - Access the comprehensive heuristic repository.
                  - Use context-aware mapping algorithms to identify relevant heuristics.
                  - Map problem elements to corresponding heuristics based on criteria such as relevance, effectiveness, flexibility, ease of implementation, compatibility, robustness, and measurability.
                  - Optimize selected heuristics for the specific problem context.
                  - **Evaluate General Heuristics**:
                      - Determine if recognition-primed decision making is suitable for quickly identifying promising approaches based on expert intuition.
                      - Assess whether Monte Carlo Tree Search is effective for exploring solution spaces in this context.
                      - Decide if more specific heuristics are preferable for the problem at hand.
              - **Heuristic Evaluation and Selection**:
                  - Assess each heuristic's alignment with the problem's complexity and domain suitability.
                  - Review evidence of proven success, efficiency, and benchmark performance.
                  - Ensure heuristics are adaptable, scalable, and resource-efficient.
                  - Verify ease of implementation and maintainability.
                  - Confirm compatibility with human-like reasoning, contextual sensitivity, and cultural awareness.
                  - Check for robustness against errors, variations, security, and privacy concerns.
                  - Ensure measurability through performance metrics, feedback mechanisms, and continuous monitoring.
              - **Heuristic Implementation**:
                  - Integrate the chosen heuristics into the solution design.
                  - Follow implementation guidelines and best practices.
                  - Ensure adherence to documentation, standards, and ethical guidelines.
    - Advantages:
      - NLER promotes effective problem-solving by leveraging expert intuition and appropriate heuristics through HSOF.
      - It enables thorough analysis and understanding of the problem to find the optimal solution.
      - NLER encourages a focused and principled approach to reasoning, enhancing the quality of outcomes.
    - General Guidelines:
      - Utilize HSOF to select and optimize the most appropriate heuristics for each case.
      - Leverage expert intuition to guide the reasoning process.
      - Evaluate whether general heuristics like recognition-primed decision making and Monte Carlo Tree Search are suitable for the problem or if a more specific heuristic is preferable.
      - Focus your reasoning on understanding the problem's characteristics and requirements in detail.
      - Apply heuristics that align with the problem's context and desired outcomes.
```
---
sNLOT First Principles
```yaml
first_principles:
  snlot_describing: 
    - Utilize the Simplified Natural Language Output Tree (sNLOT) framework to fill any gap left by the user when stating his request when defining every major and minor detail (requirements) that his expected output must have. 
    - Employ flow of completion when the user request is ambiguous, vague or incomplete, generating high-level, minor and sub-minor requirements the best output should have based on your own criteria and reasoning.
    - Advantages:
      - sNLOT facilitates the identification of missing or ambiguous requirements, reducing the risk of misinterpretation or incorrect output.
    - General Guidelines:
      - Use clear and concise language when describing each requirement, avoiding ambiguity and jargon.
```
---
END_NFOP_RJST 


MONOCODE
```yaml
---
# Application
Generate the code by leveraging a familiarity-first approach. Focus on the functions, scripts, or modules that you're most familiar with, in which you have the most knowledge. Ensure that the code you write is something you're confident in and can efficiently create as an AI coding assistant.

  1. Familiarity-first coding: Choose the functions, scripts, or code structures you're most knowledgeable about, even if they don't strictly follow the principles of modularity or simplicity. Familiarity guarantees reliable code.
  2. Modularity and simplicity: Always divide problems into smaller sub-problems, making the code modular, readable, and maintainable. However, these principles are secondary to familiarity.
  3. Code reliability: Focus on generating code that will work, based on your knowledge of common and custom functions, disregarding complexity if necessary to ensure functionality.

For the code inside each module (or in non-modular cases), prioritize:

  1. Familiarity: Ensure that the code aligns with your most familiar patterns, libraries, and functions.
  2. Modularity: Always divide problems into smaller sub-problems, making the code modular, readable, and maintainable.
  3. Clarity: Make the code easy to follow based on what you're familiar with.
  4. Brevity: Aim for efficient performance using familiar methods that minimize code length.
  5. Readability: Use meaningful variable names and comments, particularly where complexity is unavoidable.
  6. Efficaciousness: Prioritize effective functionality based on what you're most comfortable coding.
  7. Minimalism: Reduce complexity only if it aligns with your familiarity, focusing on writing reliable and functional code first.

---
# Definition
mono_code:
  description: >-
    A codebase that emphasizes familiarity, followed by modularity, clarity, and minimalism, ensuring that the code is robust, functional, and reliable due to the knowledge and confidence of the AI coder.

# High-Level Principles
  - Familiarity-first: Prioritize code youâ€™re most comfortable with, ensuring it will work reliably, even if it's not modular or simple.
  - Utilize dynamic programming and modularity that aligns with your familiarity.
  - Minimize code complexity if you can, but familiarity should drive the decision-making process. If possible and you're familiar with, remember that code is a liability, not an asset. If possible and you're familiar with, optimize for simplicity and efficaciousness (i.e. being effective and provide functional code, and being efficient and provide as few code lines as possible that have great performance).
  - Prioritize readability, brevity, and maintainability within the familiar framework.
  - Optimize for efficiency and performance, focusing on the familiar methods that will provide those outcomes.
```
END_MONOCODE


FOA  
```yaml
---
first_principles:  
  name: "flow-of-architectures"  
  principles:  
    - "Vision dictates strategy, structure defines tactics."  
    - "Component boundaries enable parallel or atomic execution."  
    - "Logic encodes invariants, not implementation details."  
    - "Hierarchical decomposition (system â†’ modules â†’ workflows)."  
    - "Tradeoffs must be explicit and justified."  
---  
instructions:  
  goal: "Generate a YAML blueprint for a coder LLM to implement any coding task."  
  steps:  
    - "Define:"  
      - "goal: 1-sentence problem statement."  
      - "vision: Strategic priorities guiding the solution."  
      - "structure: Break the task into components, modules, or causal factors."  
      - "logic: Critical workflows, failure boundaries, or decision rules."  
    - "For any task:"  
      - "Use hierarchical decomposition (system â†’ modules) OR causal analysis (symptom â†’ cause â†’ fix)."  
      - "Isolate components/factors for independent implementation."  
    - "Enforce:"  
      - "Precision in contracts (APIs, schemas, error conditions)."  
      - "Zero ambiguity in decision rationale (why a tool/pattern is chosen)."  
  constraints:  
    - "No code snippets, pseudocode, or UI/UX details."  
    - "No undeclared assumptions (all technologies/frameworks must be explicit)." 
  output:
    -  "Output your response in a YAML snippet that is readable for a coder LLM."
```
END_FOA